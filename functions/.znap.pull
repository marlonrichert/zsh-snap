#!/bin/zsh
# update repos in parallel
# args: [ <repo> ... ]
zmodload -F zsh/files b:zf_ln b:zf_rm
autoload +X -Uz is-at-least

.znap.pull() {
  emulate -L zsh; setopt $_znap_opts

  local bindir=~/.local/bin
  local fdir=${XDG_DATA_HOME:-~/.local/share}/zsh/site-functions

  private -a bugs=(
      $bindir/*.*(@-*)
      $bindir/*(@-^*)
      $bindir/*(-@)
      $fdir/*.zwc
      $fdir/*(-@)
  )

  private b=
  for b in $bugs[@]; do
    [[ $b:P == ~znap/*/* ]] &&
        zf_rm $b
  done

  private -a repos=( ~znap/$^@(D-/) )
  private r=

  (( ${#repos} )) ||
      repos=( ~znap/*/.git(D-/:h) )

  for r in $repos; do
    git -C $r config --local submodule.fetchJobs 0
  done

  if is-at-least 2.31 ${${=$( git --version )}[3]}; then
    local -a match=() mbegin=() mend=()
    for r in $repos; do
      if zstyle -T :znap:pull:${r:t} git-maintenance; then
        git -C $r maintenance start &> /dev/null
      else
        git -C $r maintenance unregister &> /dev/null
      fi
    done
  fi

  {
    .znap.multi '.znap.pull.task '${(i)^repos}
  } always {
    .znap.compile ${XDG_DATA_HOME:-~/.local/share}/zsh/site-functions
  }
}

.znap.pull.task() {
  emulate -L zsh; setopt $_znap_opts

  cd -q ~znap
  print -nr -- "${$( eval "ls -d $1:t" )%[/@]} "
  cd -q $1

  local -a upstream=()
  ..znap.fetch ||
      return

  .znap.ignore $1:t '*.zwc'  # Add `*.zwc` to repo's local ignore list.

  private -a count=()
  if count=( ${="$( git rev-list --count --left-right @{u}...@ 2> /dev/null )"} ); then
    if (( count[2] )); then
      print -P "%F{yellow}ahead $count[2]%f"
      return
    fi

    if (( count[1] )); then
      print -n 'updating... '

      local msg=
      if ! msg=$( git pull -q -r --recurse-submodules $upstream[@] 2>&1 > /dev/null ); then
        ..znap.error $=msg
        return
      else
        private cache_dir=$XDG_CACHE_HOME/zsh-snap
        zf_rm -f -- $_comp_dumpfile $cache_dir/fpath/_$1:t $cache_dir/eval/${1:t}.zsh
        .znap.compile $1 &> /dev/null &|

        private -i installed=0
        private link= orig= opt=
        for link in $bindir/*~*.zwc(@) $fdir/*~*.zwc(@); do
          orig=$link:P
          if [[ $orig == $1/* ]]; then
            if ! [[ -e $orig ]]; then
              zf_rm -f -- $link
              continue
            fi
            if [[ $orig == $bindir/* && -x $orig ]]; then
              installed=1
            elif [[ $orig == $fdir/* ]]; then
              local REPLY
              IFS='' read -r < $orig
              if  [[ $orig == $fdir/_* &&
                    $REPLY == (\#|autoload |emulate )* ]] ||
                  [[ $orig == $fdir/[^[:punct:][:upper:]][^.]## &&
                    $REPLY == \#(autoload|compdef)\ * ]]; then
                installed=1
              fi
            fi
            .znap.compile $orig
          fi
        done

        (( installed )) &&
            .znap.install $1:t
      fi
    fi
  fi
  print -P '%F{green}âœ“%f'
}

.znap.pull "$@"
